"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_, p1) => `${p1}[^\\/]*`
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError2 = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path8, originalPath, doThrow) => {
      if (!isString(path8)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path8) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path8)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path8) => REGEX_TEST_INVALID_PATH.test(path8);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path8, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path8);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path8 = originalPath && checkPath.convert(originalPath);
        checkPath(path8, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError2);
        return this._t(path8, cache, checkUnignored, slices);
      }
      _t(path8, cache, checkUnignored, slices) {
        if (path8 in cache) {
          return cache[path8];
        }
        if (!slices) {
          slices = path8.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path8] = this._testOne(path8, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        return cache[path8] = parent.ignored ? parent : this._testOne(path8, checkUnignored);
      }
      ignores(path8) {
        return this._test(path8, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path8) => !this.ignores(path8);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path8) {
        return this._test(path8, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path8) => checkPath(path8 && checkPath.convert(path8), path8, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path8) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path8) || isNotRelative(path8);
    }
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc16 = require("coc.nvim");
var import_fs7 = __toESM(require("fs"));
var import_path7 = __toESM(require("path"));

// src/config.ts
var import_coc = require("coc.nvim");
function getConfigBladeEnable() {
  return import_coc.workspace.getConfiguration("blade").get("enable", true);
}
function getConfigBladeFormatterEnable() {
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.enable", true);
}
function getConfigBladeLinterEnable() {
  return import_coc.workspace.getConfiguration("blade").get("bladeLinter.enable", true);
}
function getConfigBladeCompletionEnable() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enable", true);
}
function getConfigBladeCompletionEnableSnippets() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableSnippets", true);
}
function getConfigBladeCompletionEnableDirective() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableDirective", true);
}
function getConfigBladeCompletionExcludeSnippets() {
  return import_coc.workspace.getConfiguration("blade").get("completion.excludeSnippets", []);
}
function getConfigBladeCompletionEnableLivewireDirectiveComponent() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableLivewireDirectiveComponent", true);
}
function getConfigBladeCompletionEnableLivewireTag() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableLivewireTag", true);
}
function getConfigBladeCompletionEnableLivewireWire() {
  return import_coc.workspace.getConfiguration("blade").get("completion.enableLivewireWire", true);
}
function getConfigBladeFormatterOptIndentSize() {
  const defaultValue = 4;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optIndentSize", defaultValue);
}
function getConfigBladeFormatterOptWrapLineLength() {
  const defaultValue = 120;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optWrapLineLength", defaultValue);
}
function getConfigBladeFormatterOptWrapAttributes() {
  const defaultValue = "auto";
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optWrapAttributes", defaultValue);
}
function getConfigBladeFormatterOptSortTailwindcssClasses() {
  const defaultValue = false;
  return import_coc.workspace.getConfiguration("blade").get("bladeFormatter.optSortTailwindcssClasses", defaultValue);
}

// src/action.ts
var import_coc2 = require("coc.nvim");
var BladeCodeActionProvider = class {
  constructor() {
  }
  async provideCodeActions(document, range, context) {
    const doc = import_coc2.workspace.getDocument(document.uri);
    const codeActions = [];
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{{-- blade-formatter-disable-next-line --}}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{{-- blade-formatter-disable-next-line --}}\n" + addIndentSpace;
      }
      const edit = import_coc2.TextEdit.insert(import_coc2.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: 'Add "blade-formatter-disable-next-line" for this line',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{{-- blade-formatter-disable --}}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{{-- blade-formatter-disable --}}\n" + addIndentSpace;
      }
      const edit = import_coc2.TextEdit.insert(import_coc2.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: 'Add "blade-formatter-disable" for this line',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.lineRange(range)) {
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const suppressLineLength = thisLineFullLength - thisLineTrimLength;
      let suppressLineNewText = "{{-- blade-formatter-enable --}}\n";
      if (suppressLineLength > 0) {
        const addIndentSpace = " ".repeat(suppressLineLength);
        suppressLineNewText = "{{-- blade-formatter-enable --}}\n" + addIndentSpace;
      }
      const edit = import_coc2.TextEdit.insert(import_coc2.Position.create(range.start.line, suppressLineLength), suppressLineNewText);
      codeActions.push({
        title: 'Add "blade-formatter-enable" for this line',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    if (this.wholeRange(doc, range) || this.cursorRange(range)) {
      const pos = import_coc2.Position.create(0, 0);
      const edit = import_coc2.TextEdit.insert(pos, "{{-- blade-formatter-disable --}}\n");
      codeActions.push({
        title: 'Add "blade-formatter-disable" for whole file',
        edit: {
          changes: {
            [doc.uri]: [edit]
          }
        }
      });
    }
    return codeActions;
  }
  wholeRange(doc, range) {
    const whole = import_coc2.Range.create(0, 0, doc.lineCount, 0);
    return whole.start.line === range.start.line && whole.start.character === range.start.character && whole.end.line === range.end.line && whole.end.character === whole.end.character;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
  cursorRange(r) {
    return r.start.line === r.end.line && r.start.character === r.end.character;
  }
};

// src/completion/provider/bladeDirective.ts
var import_coc3 = require("coc.nvim");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var BladeDirectiveCompletionProvider = class {
  constructor(context) {
    this._context = context;
    this.directiveJsonPaths = [
      import_path.default.join(this._context.extensionPath, "data", "completion", "blade-directive.json"),
      import_path.default.join(this._context.extensionPath, "data", "completion", "livewire-directive.json")
    ];
  }
  async getCompletionItems(completionDataPath, text, position) {
    const completionList = [];
    if (import_fs.default.existsSync(completionDataPath)) {
      const completionJsonText = import_fs.default.readFileSync(completionDataPath, "utf8");
      const completionJson = JSON.parse(completionJsonText);
      if (completionJson) {
        Object.keys(completionJson).map((key) => {
          const docDataPath = import_path.default.join(this._context.extensionPath, "data", "documantation", "blade", key.replace("@", "") + ".md");
          let documentationText;
          try {
            documentationText = import_fs.default.readFileSync(docDataPath, "utf8");
          } catch (e) {
            documentationText = void 0;
          }
          const edit = {
            range: {
              start: { line: position.line, character: position.character - text.length },
              end: position
            },
            newText: key
          };
          completionList.push({
            label: key,
            kind: import_coc3.CompletionItemKind.Text,
            insertText: key,
            detail: completionJson[key],
            textEdit: edit,
            documentation: documentationText
          });
        });
      }
    }
    return completionList;
  }
  async provideCompletionItems(document, position, token, context) {
    const doc = import_coc3.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc3.Position.create(position.line, position.character - 1), "@");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (!text.startsWith("@"))
      return [];
    const completionItemList = [];
    this.directiveJsonPaths.forEach((v) => {
      this.getCompletionItems(v, text, position).then((vv) => completionItemList.push(...vv));
    });
    return completionItemList;
  }
};

// src/completion/provider/bladeSnippets.ts
var import_coc4 = require("coc.nvim");
var import_fs2 = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
var BladeSnippetsCompletionProvider = class {
  constructor(context, outputChannel) {
    this._context = context;
    this._outputChannel = outputChannel;
    this.snippetsFilePaths = [
      import_path2.default.join(this._context.extensionPath, "data", "snippets", "snippets.json"),
      import_path2.default.join(this._context.extensionPath, "data", "snippets", "helpers.json"),
      import_path2.default.join(this._context.extensionPath, "data", "snippets", "blade.json"),
      import_path2.default.join(this._context.extensionPath, "data", "snippets", "livewire.json")
    ];
    this.excludeSnippetsKeys = getConfigBladeCompletionExcludeSnippets();
  }
  async getSnippetsCompletionItems(snippetsFilePath, text, position) {
    const snippetsCompletionList = [];
    if (import_fs2.default.existsSync(snippetsFilePath)) {
      const snippetsJsonText = import_fs2.default.readFileSync(snippetsFilePath, "utf8");
      const snippetsJson = JSON.parse(snippetsJsonText);
      if (snippetsJson) {
        Object.keys(snippetsJson).map((key) => {
          if (this.excludeSnippetsKeys.includes(snippetsJson[key].prefix))
            return;
          let snippetsText;
          const body = snippetsJson[key].body;
          if (body instanceof Array) {
            snippetsText = body.join("\n");
          } else {
            snippetsText = body;
          }
          const edit = {
            range: {
              start: { line: position.line, character: position.character - text.length },
              end: position
            },
            newText: snippetsJson[key].prefix
          };
          snippetsCompletionList.push({
            label: snippetsJson[key].prefix,
            kind: import_coc4.CompletionItemKind.Snippet,
            detail: snippetsJson[key].description,
            documentation: { kind: "markdown", value: "```blade\n" + snippetsText + "\n```" },
            insertTextFormat: import_coc4.InsertTextFormat.Snippet,
            textEdit: edit,
            data: snippetsText
          });
        });
      }
    }
    return snippetsCompletionList;
  }
  async provideCompletionItems(document, position, token, context) {
    const doc = import_coc4.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc4.Position.create(position.line, position.character - 1), ":<");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (text.match(/(<livewire:).*$/))
      return [];
    const completionItemList = [];
    this.snippetsFilePaths.forEach((v) => {
      this.getSnippetsCompletionItems(v, text, position).then((vv) => completionItemList.push(...vv));
    });
    return completionItemList;
  }
  async resolveCompletionItem(item) {
    if (item.textEdit) {
      item.textEdit.newText = item.data;
    }
    return item;
  }
};

// src/completion/provider/livewireDirectiveComponent.ts
var import_coc6 = require("coc.nvim");

// src/completion/util/livewireUtil.ts
var import_coc5 = require("coc.nvim");
var import_fs3 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
async function getAllComponents(prefix) {
  const componentWithSrcFile = [];
  try {
    const text = await import_fs3.default.promises.readFile(import_path3.default.join(import_coc5.workspace.root, "bootstrap", "cache", "livewire-components.php"), {
      encoding: "utf8"
    });
    const regex = /'(.*)'\s*=>\s*'(.*)',*/g;
    const matches = [...text.matchAll(regex)];
    for (const m of matches) {
      if (!prefix || m[1].startsWith(prefix)) {
        componentWithSrcFile.push({
          name: m[1],
          srcFile: m[2]
        });
      }
    }
  } catch (e) {
  }
  return componentWithSrcFile;
}
async function getAllComponentsWithProps(prefix) {
  const componentWithProps = [];
  try {
    const components = await getAllComponents(prefix);
    for (const component of components) {
      const params = await getComponentParams(component.name, component.srcFile);
      const properties = await getComponentPropertiesFromComponent(component.name, component.srcFile);
      const prepareProps = [];
      if (params)
        prepareProps.push(...params.filter((v) => !!v));
      if (properties)
        prepareProps.push(...properties.filter((v) => !!v));
      const props = [...new Set(prepareProps)];
      componentWithProps.push({
        name: component.name,
        props: props ? props : void 0
      });
    }
  } catch (e) {
  }
  return componentWithProps;
}
async function getComponentPath(componentName) {
  try {
    const components = await getAllComponents();
    const component = components.find((component2) => component2.name === componentName);
    if (!component) {
      throw new Error("Cannot find component");
    }
    return component.srcFile;
  } catch (e) {
    return void 0;
  }
}
async function getComponentClassSource(component, srcFile) {
  try {
    if (!srcFile) {
      srcFile = await getComponentPath(component);
    }
    if (!srcFile) {
      throw new Error("Cannot find class src file");
    }
    srcFile = srcFile.replace(/\\\\/g, import_path3.default.sep);
    srcFile = srcFile.replace(/App/g, "app");
    const srcFileSplit = srcFile.split(import_path3.default.sep);
    return await import_fs3.default.promises.readFile(import_path3.default.join(import_coc5.workspace.root, ...srcFileSplit) + ".php", {
      encoding: "utf8"
    });
  } catch (e) {
    return null;
  }
}
async function getComponentParams(component, srcFile) {
  try {
    const classText = await getComponentClassSource(component, srcFile);
    if (!classText) {
      throw new Error("Cannot find class");
    }
    const match = /function\s*mount\s*\(([^\)]*)/gm.exec(classText);
    if (!match || !match.length) {
      throw new Error("Cannot find mount() function");
    }
    const variables = match[1].split(/,/gm);
    const params = [];
    for (const variable of variables) {
      const words = variable.split(/\$/gm);
      if (words.length) {
        params.push(words[1]);
      }
    }
    return params;
  } catch (e) {
    return null;
  }
}
async function getComponentFromView(viewFile) {
  try {
    viewFile = viewFile.replace(/\\/g, import_path3.default.sep);
    const viewMatch = new RegExp(`.*${import_path3.default.sep}resources${import_path3.default.sep}views${import_path3.default.sep}(.*).blade.php`).exec(viewFile);
    if (!viewMatch || !viewMatch.length) {
      throw new Error("View file path is not correct");
    }
    let view;
    if (process.platform === "win32") {
      view = viewMatch[1].replace(/\\/g, "\\.");
    } else {
      view = viewMatch[1].replace(/\//g, "\\.");
    }
    const components = await getAllComponents();
    for (const component of components) {
      const classText = await getComponentClassSource(component.name, component.srcFile);
      if (!classText) {
        continue;
      }
      const match = new RegExp(view, "mg").exec(classText);
      if (match) {
        return component;
      }
    }
    return null;
  } catch (e) {
    return null;
  }
}
async function getComponentActionsFromView(viewFile) {
  try {
    const component = await getComponentFromView(viewFile);
    if (!component) {
      throw new Error("Cannot find component");
    }
    const classText = await getComponentClassSource(component.name, component.srcFile);
    if (!classText) {
      throw new Error("Cannot find component source");
    }
    const regex = /^\s*(?:public\s+)?function\s*(\w+)/gm;
    const actions = [];
    while (true) {
      const match = regex.exec(classText);
      if (!match) {
        break;
      }
      if (match && match.length) {
        if (match[1] !== "mount" && match[1] !== "render") {
          actions.push(match[1]);
        }
      }
    }
    return actions;
  } catch (e) {
    return null;
  }
}
async function getComponentPropertiesFromView(viewFile) {
  try {
    const component = await getComponentFromView(viewFile);
    if (!component) {
      throw new Error("Cannot find component");
    }
    const classText = await getComponentClassSource(component.name, component.srcFile);
    if (!classText) {
      throw new Error("Cannot find component source");
    }
    const regex = /(?<![\/\*#].*)public\s+\$(\w+)/gm;
    const actions = [];
    while (true) {
      const match = regex.exec(classText);
      if (!match) {
        break;
      }
      if (match && match.length) {
        actions.push(match[1]);
      }
    }
    return actions;
  } catch (e) {
    return null;
  }
}
async function getComponentPropertiesFromComponent(name, srcFile) {
  try {
    const classText = await getComponentClassSource(name, srcFile);
    if (!classText) {
      throw new Error("Cannot find component source");
    }
    const regex = /(?<![\/\*#].*)public\s+\$(\w+)/gm;
    const actions = [];
    while (true) {
      const match = regex.exec(classText);
      if (!match) {
        break;
      }
      if (match && match.length) {
        actions.push(match[1]);
      }
    }
    return actions;
  } catch (e) {
    return null;
  }
}

// src/completion/provider/livewireDirectiveComponent.ts
var LivewireDirectiveComponentProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /@livewire\(([A-Za-z0-9_.-]*)$/g.exec(linePrefix);
    if (!match) {
      return [];
    }
    const prefix = match[1] || "";
    const completionList = await getAllComponentsWithProps(prefix);
    return completionList.map((c) => {
      let completeText = `'${c.name}'`;
      if (c.props && c.props.length) {
        const props = [];
        for (let i = 0; i < c.props.length; i++) {
          props.push(`'\${${i + 2}:${c.props[i]}}' => ''`);
        }
        completeText += `\${1:, [${props.join(", ")}]}`;
      }
      const item = {
        label: `${c.name}`,
        kind: import_coc6.CompletionItemKind.Method,
        insertText: new import_coc6.SnippetString(completeText).value,
        insertTextFormat: import_coc6.InsertTextFormat.Snippet
      };
      return item;
    });
  }
};

// src/completion/provider/livewireTag.ts
var import_coc7 = require("coc.nvim");
var LivewireTagProvider = class {
  provideCompletionItems(document, position, token, context) {
    const doc = import_coc7.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc7.Position.create(position.line, position.character - 1), "<");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (!text.startsWith("<"))
      return [];
    const item = {
      label: "livewire",
      kind: import_coc7.CompletionItemKind.Text,
      insertText: new import_coc7.SnippetString("livewire:${1}").value,
      insertTextFormat: import_coc7.InsertTextFormat.Snippet,
      command: { command: "editor.action.triggerSuggest", title: "Re-trigger completions..." }
    };
    return [item];
  }
};

// src/completion/provider/livewireTagComponent.ts
var import_coc8 = require("coc.nvim");
var LivewireTagComponentProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /<livewire:([A-Za-z0-9_.-]*)$/g.exec(linePrefix);
    if (!match) {
      return [];
    }
    const prefix = match[1] || "";
    const completionList = await getAllComponentsWithProps(prefix);
    const words = prefix.split(/\W+/g);
    const prefixLen = prefix.length - (words.length ? words[words.length - 1].length : 0);
    return completionList.map((c) => {
      let params = "";
      if (c.props && c.props.length) {
        for (let i = 0; i < c.props.length; i++) {
          if (c.props[i]) {
            params += ` :\${${i + 1}:${c.props[i]}=''}`;
          }
        }
      }
      const item = {
        label: "livewire:" + c.name,
        kind: import_coc8.CompletionItemKind.Method,
        insertText: new import_coc8.SnippetString(`livewire:${c.name.slice(prefixLen)}${params}`).value,
        insertTextFormat: import_coc8.InsertTextFormat.Snippet
      };
      return item;
    });
  }
};

// src/completion/provider/livewireWire.ts
var import_coc9 = require("coc.nvim");
var LivewireWireProvider = class {
  provideCompletionItems(document, position, token, context) {
    const doc = import_coc9.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc9.Position.create(position.line, position.character - 1), "<");
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (text.startsWith("<"))
      return [];
    const item = {
      label: "wire",
      kind: import_coc9.CompletionItemKind.Text,
      insertText: new import_coc9.SnippetString("wire:").value,
      insertTextFormat: import_coc9.InsertTextFormat.Snippet,
      command: { command: "editor.action.triggerSuggest", title: "Re-trigger completions..." }
    };
    return [item];
  }
};

// src/completion/provider/livewireWireAction.ts
var import_coc10 = require("coc.nvim");
var LivewireWireActionProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /(?:^|\s+)wire:(\w+)(?:\.(\w+))?(?:\.?([A-Za-z0-9_.]*))=(['"][A-Za-z0-9_.]*)?$/g.exec(linePrefix);
    if (!match || match.length < 4) {
      return [];
    }
    let attributes = [];
    switch (match[1]) {
      case "click":
        attributes = await getComponentActionsFromView(import_coc10.Uri.parse(document.uri).fsPath) || [];
        break;
      case "model":
        attributes = await getComponentPropertiesFromView(import_coc10.Uri.parse(document.uri).fsPath) || [];
        break;
    }
    if (!match[4] && !attributes.length) {
      return [];
    }
    const completionList = attributes.map((attribute) => {
      const item = {
        label: attribute,
        kind: import_coc10.CompletionItemKind.Value,
        insertText: new import_coc10.SnippetString(`${match[4] ? "" : "'"}\${1:${attribute}}${match[4] ? "" : "'"}`).value,
        insertTextFormat: import_coc10.InsertTextFormat.Snippet
      };
      return item;
    });
    return completionList;
  }
};

// src/completion/provider/livewireWireEvent.ts
var import_coc11 = require("coc.nvim");
var LivewireWireEventProvider = class {
  async provideCompletionItems(document, position, token, context) {
    const linePrefix = document.lineAt(position).text.slice(0, position.character);
    const match = /(?:^|\s+)wire:(\w*)(?:(?:\.?)([A-Za-z0-9_.]*))?$/g.exec(linePrefix);
    if (!match || match.length < 3) {
      return [];
    }
    const attributes = [
      "key",
      "model",
      "model.debounce.100ms",
      "model.debounce.500ms",
      "model.lazy",
      "model.defer",
      "poll",
      "poll.500ms",
      "poll.keep-alive",
      "poll.visible",
      "init",
      "loading",
      "loading.class",
      "loading.class.remove",
      "loading.attr",
      "loading.delay",
      "loading.delay.shortest",
      "loading.delay.shorter",
      "loading.delay.short",
      "loading.delay.long",
      "loading.delay.longer",
      "loading.delay.longest",
      "dirty",
      "dirty.class",
      "dirty.class.remove",
      "dirty.attr",
      "offline",
      "offline.class",
      "offline.class.remove",
      "offline.attr",
      "target",
      "ignore",
      "ignore.self",
      "abort",
      "afterprint",
      "animationend",
      "animationiteration",
      "animationstart",
      "beforeprint",
      "beforeunload",
      "blur",
      "canplay",
      "canplaythrough",
      "change",
      "click",
      "click.prefetch",
      "contextmenu",
      "copy",
      "cut",
      "dblclick",
      "drag",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "dragstart",
      "drop",
      "durationchange",
      "ended",
      "error",
      "focus",
      "focusin",
      "focusout",
      "fullscreenchange",
      "fullscreenerror",
      "hashchange",
      "input",
      "invalid",
      "keydown",
      "keydown.enter",
      "keypress",
      "keyup",
      "load",
      "loadeddata",
      "loadedmetadata",
      "loadstart",
      "message",
      "mousedown",
      "mouseenter",
      "mouseleave",
      "mousemove",
      "mouseover",
      "mouseout",
      "mouseup",
      "online",
      "open",
      "pagehide",
      "pageshow",
      "paste",
      "pause",
      "play",
      "playing",
      "popstate",
      "progress",
      "ratechange",
      "resize",
      "reset",
      "scroll",
      "search",
      "seeked",
      "seeking",
      "select",
      "show",
      "stalled",
      "storage",
      "submit",
      "submit.prevent",
      "suspend",
      "timeupdate",
      "toggle",
      "touchcancel",
      "touchend",
      "touchmove",
      "touchstart",
      "transitionend",
      "unload",
      "volumechange",
      "waiting",
      "wheel"
    ];
    const completionList = attributes.map((attribute) => {
      const item = {
        label: "wire:" + attribute,
        kind: import_coc11.CompletionItemKind.Field
      };
      return item;
    });
    return completionList;
  }
};

// src/definition.ts
var import_coc12 = require("coc.nvim");
var import_fs4 = __toESM(require("fs"));
var BladeDefinitionProvider = class {
  provideDefinition(document, position, token) {
    const doc = import_coc12.workspace.getDocument(document.uri);
    if (!doc)
      return null;
    const wordRange = doc.getWordRangeAtPosition(position, `-."'`);
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    let locationPath;
    if (text.startsWith("x-jet-")) {
      locationPath = this.getComponentLocationPath(import_coc12.workspace.root, text, true);
    } else if (text.startsWith("x-")) {
      locationPath = this.getComponentLocationPath(import_coc12.workspace.root, text, false);
    } else if (text.startsWith('"') || text.startsWith("'")) {
      const templateStr = text.replace(/\"/g, "").replace(/\'/g, "");
      locationPath = this.getTemplateLocationPath(import_coc12.workspace.root, templateStr);
    }
    if (locationPath) {
      const location = {
        uri: locationPath,
        range: import_coc12.Range.create(import_coc12.Position.create(0, 0), import_coc12.Position.create(0, 0))
      };
      return location;
    }
    return null;
  }
  getComponentLocationPath(workspaceRootPath, componentTag, isJet) {
    let componentText = componentTag.replace(/^x-/, "");
    if (isJet) {
      componentText = componentTag.replace(/^x-jet-/, "");
    }
    let componentPath = this.componentNameToPath(componentText, isJet);
    if (!import_fs4.default.existsSync(workspaceRootPath + componentPath)) {
      componentPath = this.componentNameToIndexPath(componentText, isJet);
      if (!import_fs4.default.existsSync(workspaceRootPath + componentPath)) {
        return void 0;
      }
    }
    const locationPath = import_coc12.Uri.parse(workspaceRootPath + componentPath).toString();
    return locationPath;
  }
  getTemplateLocationPath(workspaceRootPath, templateStr) {
    let templatePath = this.templateNameToPath(templateStr);
    if (!import_fs4.default.existsSync(workspaceRootPath + templatePath)) {
      templatePath = this.templateNameToIndexPath(templateStr);
      if (!import_fs4.default.existsSync(workspaceRootPath + templatePath)) {
        return void 0;
      }
    }
    const locationPath = import_coc12.Uri.parse(workspaceRootPath + templatePath).toString();
    return locationPath;
  }
  componentNameToPath(path8, isJet) {
    if (isJet) {
      return `/resources/views/vendor/jetstream/components/${path8.replace(/\./g, "/")}.blade.php`;
    } else {
      return `/resources/views/components/${path8.replace(/\./g, "/")}.blade.php`;
    }
  }
  componentNameToIndexPath(path8, isJet) {
    if (isJet) {
      return `/resources/views/vendor/jetstream/components/${path8.replace(/\./g, "/")}/index.blade.php`;
    } else {
      return `/resources/views/components/${path8.replace(/\./g, "/")}/index.blade.php`;
    }
  }
  templateNameToPath(path8) {
    return `/resources/views/${path8.replace(/\./g, "/")}.blade.php`;
  }
  templateNameToIndexPath(path8) {
    return `/resources/views/${path8.replace(/\./g, "/")}/index.blade.php`;
  }
};

// src/format.ts
var import_coc13 = require("coc.nvim");
var import_fs5 = __toESM(require("fs"));
var import_ignore = __toESM(require_ignore());
var import_path5 = __toESM(require("path"));

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// node_modules/synckit/lib/index.js
var import_path4 = __toESM(require("path"), 1);
var import_worker_threads = require("worker_threads");
var _a;
var { SYNCKIT_BUFFER_SIZE, SYNCKIT_TIMEOUT, SYNCKIT_TS_ESM, SYNCKIT_EXEC_ARV } = process.env;
var TS_USE_ESM = !!SYNCKIT_TS_ESM && ["1", "true"].includes(SYNCKIT_TS_ESM);
var DEFAULT_BUFFER_SIZE = SYNCKIT_BUFFER_SIZE ? +SYNCKIT_BUFFER_SIZE : void 0;
var DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : void 0;
var DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_BUFFER_SIZE || 1024;
var DEFAULT_EXEC_ARGV = (_a = SYNCKIT_EXEC_ARV === null || SYNCKIT_EXEC_ARV === void 0 ? void 0 : SYNCKIT_EXEC_ARV.split(",")) !== null && _a !== void 0 ? _a : [];
var syncFnCache = /* @__PURE__ */ new Map();
function createSyncFn(workerPath, bufferSizeOrOptions, timeout) {
  if (!import_path4.default.isAbsolute(workerPath)) {
    throw new Error("`workerPath` must be absolute");
  }
  const cachedSyncFn = syncFnCache.get(workerPath);
  if (cachedSyncFn) {
    return cachedSyncFn;
  }
  const syncFn = startWorkerThread(workerPath, typeof bufferSizeOrOptions === "number" ? { bufferSize: bufferSizeOrOptions, timeout } : bufferSizeOrOptions);
  syncFnCache.set(workerPath, syncFn);
  return syncFn;
}
var throwError = (msg) => {
  throw new Error(msg);
};
function startWorkerThread(workerPath, { bufferSize = DEFAULT_WORKER_BUFFER_SIZE, timeout = DEFAULT_TIMEOUT, execArgv = DEFAULT_EXEC_ARGV } = {}) {
  const { port1: mainPort, port2: workerPort } = new import_worker_threads.MessageChannel();
  const isTs = workerPath.endsWith(".ts");
  const worker = new import_worker_threads.Worker(isTs ? TS_USE_ESM ? throwError("Native esm in `.ts` file is not supported yet, please use `.cjs` instead") : `require('ts-node/register');require('${workerPath}')` : workerPath, {
    eval: isTs,
    workerData: { workerPort },
    transferList: [workerPort],
    execArgv
  });
  let nextID = 0;
  const syncFn = (...args) => {
    const id = nextID++;
    const sharedBuffer = new SharedArrayBuffer(bufferSize);
    const sharedBufferView = new Int32Array(sharedBuffer);
    const msg = { sharedBuffer, id, args };
    worker.postMessage(msg);
    const status = Atomics.wait(sharedBufferView, 0, 0, timeout);
    if (!["ok", "not-equal"].includes(status)) {
      throw new Error("Internal error: Atomics.wait() failed: " + status);
    }
    const { id: id2, result, error } = (0, import_worker_threads.receiveMessageOnPort)(mainPort).message;
    if (id !== id2) {
      throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
    }
    if (error) {
      throw error;
    }
    return result;
  };
  worker.unref();
  return syncFn;
}

// src/format.ts
async function doFormat(context, outputChannel, document, range) {
  const fileName = import_coc13.Uri.parse(document.uri).fsPath;
  const originalText = document.getText(range);
  if (document.languageId !== "blade") {
    import_coc13.window.showErrorMessage("blade-formatter cannot run, not a blade file");
    return originalText;
  }
  const formatIndentSize = getConfigBladeFormatterOptIndentSize();
  const formatWrapLineLength = getConfigBladeFormatterOptWrapLineLength();
  const formatWrapAttributes = getConfigBladeFormatterOptWrapAttributes();
  const formatSortTailwindcssClasses = getConfigBladeFormatterOptSortTailwindcssClasses();
  const options = {
    indentSize: formatIndentSize,
    wrapAttributes: formatWrapAttributes,
    wrapLineLength: formatWrapLineLength,
    sortTailwindcssClasses: formatSortTailwindcssClasses ? formatSortTailwindcssClasses : void 0
  };
  const cwd = import_coc13.Uri.file(import_coc13.workspace.root).fsPath;
  const opts = { cwd };
  outputChannel.appendLine(`${"#".repeat(10)} blade-formatter
`);
  outputChannel.appendLine(`Cwd: ${opts.cwd}`);
  outputChannel.appendLine(`Option: ${JSON.stringify(options)}`);
  outputChannel.appendLine(`File: ${fileName}`);
  const isIgnoreFile = shouldIgnore(fileName, outputChannel);
  if (isIgnoreFile) {
    import_coc13.window.showWarningMessage(".bladeignore matched file.");
    return originalText;
  }
  return new Promise((resolve, reject) => {
    const workerPath = import_path5.default.join(context.extensionPath, "worker", "index.js");
    const syncFn = createSyncFn(workerPath);
    let newText = "";
    try {
      newText = syncFn(originalText, options);
      outputChannel.appendLine(`
==== OUTPUT ===
`);
      outputChannel.appendLine(`${newText}`);
      outputChannel.appendLine(`== success ==
`);
      resolve(newText);
    } catch (error) {
      import_coc13.window.showWarningMessage(`Formatting failed due to an error in the template.
${error.message}`);
      outputChannel.appendLine(`
==== ERROR ===
`);
      outputChannel.appendLine(`${error.message}`);
      outputChannel.appendLine(`
==== originalText: ===
`);
      outputChannel.appendLine(`${originalText}`);
      reject(error);
    }
  });
}
function fullDocumentRange(document) {
  const lastLineId = document.lineCount - 1;
  const doc = import_coc13.workspace.getDocument(document.uri);
  return import_coc13.Range.create({ character: 0, line: 0 }, { character: doc.getline(lastLineId).length, line: lastLineId });
}
var BladeFormattingEditProvider = class {
  constructor(context, outputChannel) {
    this._context = context;
    this._outputChannel = outputChannel;
  }
  provideDocumentFormattingEdits(document) {
    return this._provideEdits(document, void 0);
  }
  async _provideEdits(document, range) {
    const code = await doFormat(this._context, this._outputChannel, document, range);
    if (!range) {
      range = fullDocumentRange(document);
    }
    return [import_coc13.TextEdit.replace(range, code)];
  }
};
function shouldIgnore(filepath, outputChannel) {
  const workspaceRootDir = import_coc13.Uri.file(import_coc13.workspace.root).fsPath;
  const ignoreFilename = ".bladeignore";
  const ignoreFilePath = import_path5.default.join(workspaceRootDir, ignoreFilename);
  if (import_fs5.default.existsSync(ignoreFilePath)) {
    const ignoreFileContent = import_fs5.default.readFileSync(ignoreFilePath, "utf-8");
    const ig = (0, import_ignore.default)().add(ignoreFileContent);
    try {
      const isMatch = ig.ignores(import_path5.default.relative(workspaceRootDir, filepath));
      if (isMatch)
        outputChannel.appendLine(`IGNORE: matched ${filepath}
`);
      return isMatch;
    } catch (err) {
      return false;
    }
  }
  return false;
}
var format_default = BladeFormattingEditProvider;

// src/hover/hover.ts
var import_coc14 = require("coc.nvim");
var import_fs6 = __toESM(require("fs"));
var import_path6 = __toESM(require("path"));

// src/hover/lang.ts
var bladeHovers = [
  {
    prefix: "@json",
    alias: []
  },
  {
    prefix: "@js",
    alias: []
  },
  {
    prefix: "@verbatim",
    alias: ["@endverbatim"]
  },
  {
    prefix: "@if",
    alias: ["@elseif", "@else", "@endif"]
  },
  {
    prefix: "@unless",
    alias: ["@endunless"]
  },
  {
    prefix: "@isset",
    alias: ["@endisset"]
  },
  {
    prefix: "@empty",
    alias: ["@endempty"]
  },
  {
    prefix: "@auth",
    alias: ["@endauth"]
  },
  {
    prefix: "@guest",
    alias: ["@endguest"]
  },
  {
    prefix: "@production",
    alias: ["@endproduction"]
  },
  {
    prefix: "@env",
    alias: ["@endenv"]
  },
  {
    prefix: "@hasSection",
    alias: []
  },
  {
    prefix: "@sectionMissing",
    alias: []
  },
  {
    prefix: "@switch",
    alias: ["@case", "@break", "@default", "@endswitch"]
  },
  {
    prefix: "@for",
    alias: ["@endfor"]
  },
  {
    prefix: "@foreach",
    alias: ["@endforeach"]
  },
  {
    prefix: "@forelse",
    alias: ["@endforelse"]
  },
  {
    prefix: "@while",
    alias: ["@endwhile"]
  },
  {
    prefix: "@continue",
    alias: []
  },
  {
    prefix: "$loop",
    alias: ["loop"]
  },
  {
    prefix: "@class",
    alias: []
  },
  {
    prefix: "@checked",
    alias: []
  },
  {
    prefix: "@selected",
    alias: []
  },
  {
    prefix: "@disabled",
    alias: []
  },
  {
    prefix: "@include",
    alias: []
  },
  {
    prefix: "@includeIf",
    alias: []
  },
  {
    prefix: "@includeWhen",
    alias: []
  },
  {
    prefix: "@includeFirst",
    alias: []
  },
  {
    prefix: "@each",
    alias: []
  },
  {
    prefix: "@once",
    alias: ["@endonce"]
  },
  {
    prefix: "@php",
    alias: ["@endphp"]
  },
  {
    prefix: "@props",
    alias: []
  },
  {
    prefix: "@aware",
    alias: []
  },
  {
    prefix: "@component",
    alias: ["@endcomponent"]
  },
  {
    prefix: "@slot",
    alias: ["endslot"]
  },
  {
    prefix: "@section",
    alias: ["@endsection"]
  },
  {
    prefix: "@show",
    alias: []
  },
  {
    prefix: "@yield",
    alias: []
  },
  {
    prefix: "@extends",
    alias: []
  },
  {
    prefix: "@parent",
    alias: []
  },
  {
    prefix: "@csrf",
    alias: []
  },
  {
    prefix: "@method",
    alias: []
  },
  {
    prefix: "@error",
    alias: ["@enderror"]
  },
  {
    prefix: "@push",
    alias: ["@endpush"]
  },
  {
    prefix: "@stack",
    alias: []
  },
  {
    prefix: "@prepend",
    alias: ["@endprepend"]
  },
  {
    prefix: "@inject",
    alias: []
  },
  {
    prefix: "@can",
    alias: ["@cannot", "@elsecan", "@endcan", "@elsecannot", "@endcannot"]
  },
  {
    prefix: "@lang",
    alias: []
  }
];

// src/hover/hover.ts
var BladeHoverProvider = class {
  constructor(context) {
    this.context = context;
  }
  async provideHover(document, position) {
    const doc = import_coc14.workspace.getDocument(document.uri);
    if (!doc)
      return null;
    const wordRange = doc.getWordRangeAtPosition(position, "@");
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    const result = await this.getHover(text, "blade");
    if (!result)
      return null;
    return {
      contents: {
        kind: "markdown",
        value: result
      }
    };
  }
  async getHover(text, hoverLang) {
    const defineHovers = bladeHovers;
    let result = "";
    for (const h in defineHovers) {
      if (text === defineHovers[h].prefix || defineHovers[h].alias.includes(text)) {
        const markdownPath = import_path6.default.join(this.context.extensionPath, "data", "documantation", hoverLang, defineHovers[h].prefix.replace(/@|\$/, "") + ".md");
        try {
          result = import_fs6.default.readFileSync(markdownPath, { encoding: "utf8" });
        } catch (e) {
          return result;
        }
        break;
      }
    }
    return result;
  }
};

// src/lint.ts
var import_coc15 = require("coc.nvim");
var import_child_process = __toESM(require("child_process"));
var BladelinterLintEngine = class {
  constructor(outputChannel) {
    this.collection = import_coc15.languages.createDiagnosticCollection("bladeLinter");
    this.outputChannel = outputChannel;
  }
  async lint(textDocument) {
    if (textDocument.languageId !== "blade")
      return;
    const self2 = this;
    const filePath = import_coc15.Uri.parse(textDocument.uri).fsPath;
    const args = [];
    const cwd = import_coc15.Uri.file(import_coc15.workspace.root).fsPath;
    const opts = { cwd, shell: true };
    args.push("artisan");
    args.push("blade:lint");
    this.outputChannel.appendLine(`${"#".repeat(10)} bladeLinter
`);
    this.outputChannel.appendLine(`Cwd: ${opts.cwd}`);
    this.outputChannel.appendLine(`Run: php ${args.join(" ")} ${filePath}`);
    this.outputChannel.appendLine(`Args: ${args.join(" ")}`);
    this.outputChannel.appendLine(`File: ${filePath}`);
    this.outputChannel.appendLine(``);
    this.collection.set(textDocument.uri);
    return new Promise(function(resolve) {
      import_child_process.default.execFile("php", [...args, filePath], opts, function(error, stdout, stderr) {
        if (stdout) {
          self2.outputChannel.appendLine(`STDOUT: ${stdout}`);
          const match = stdout.match(/^.*:\s*(.*)\sin\s.*\son\sline\s(\d)/);
          let msg = "";
          let line = 1;
          if (match) {
            msg = match[1];
            line = parseInt(match[2]);
          } else {
            msg = "There is a problem running larvel-blade-linter";
          }
          const startPosition = import_coc15.Position.create(line - 1, 0);
          const endPosition = import_coc15.Position.create(line - 1, 0);
          const diagnostic = {
            range: import_coc15.Range.create(startPosition, endPosition),
            message: msg,
            severity: import_coc15.DiagnosticSeverity.Error,
            source: "bladeLinter",
            relatedInformation: []
          };
          self2.collection.set(textDocument.uri, [diagnostic]);
        }
        resolve();
      });
    });
  }
};

// src/index.ts
var formatterHandler;
function disposeHandlers() {
  if (formatterHandler) {
    formatterHandler.dispose();
  }
  formatterHandler = void 0;
}
async function activate(context) {
  if (!getConfigBladeEnable())
    return;
  const outputChannel = import_coc16.window.createOutputChannel("blade");
  const extensionStoragePath = context.storagePath;
  if (!import_fs7.default.existsSync(extensionStoragePath)) {
    import_fs7.default.mkdirSync(extensionStoragePath);
  }
  const languageSelector = [{ language: "blade", scheme: "file" }];
  context.subscriptions.push(import_coc16.commands.registerCommand("blade.showOutput", () => {
    if (outputChannel) {
      outputChannel.show();
    }
  }));
  if (getConfigBladeFormatterEnable()) {
    let registerFormatter2 = function() {
      disposeHandlers();
      formatterHandler = import_coc16.languages.registerDocumentFormatProvider(languageSelector, editProvider, priority);
    };
    var registerFormatter = registerFormatter2;
    const editProvider = new format_default(context, outputChannel);
    const priority = 1;
    registerFormatter2();
    context.subscriptions.push(import_coc16.commands.registerCommand("blade.bladeFormatter.run", async () => {
      const doc = await import_coc16.workspace.document;
      const code = await doFormat(context, outputChannel, doc.textDocument, void 0);
      const edits = [import_coc16.TextEdit.replace(fullDocumentRange(doc.textDocument), code)];
      if (edits) {
        await doc.applyEdits(edits);
      }
    }));
  }
  if (getConfigBladeLinterEnable()) {
    if (import_fs7.default.existsSync(import_path7.default.join(import_coc16.workspace.root, "artisan")) && import_fs7.default.existsSync(import_path7.default.join(import_coc16.workspace.root, "vendor", "bdelespierre", "laravel-blade-linter"))) {
      const engine = new BladelinterLintEngine(outputChannel);
      import_coc16.workspace.documents.map(async (doc) => {
        await engine.lint(doc.textDocument);
      });
      import_coc16.workspace.onDidOpenTextDocument(async (e) => {
        await engine.lint(e);
      }, null, context.subscriptions);
      import_coc16.workspace.onDidSaveTextDocument(async (e) => {
        await engine.lint(e);
      }, null, context.subscriptions);
    }
  }
  if (getConfigBladeCompletionEnable()) {
    const { document } = await import_coc16.workspace.getCurrentState();
    if (document.languageId === "blade") {
      const existsBladeIndent = await import_coc16.workspace.nvim.eval('exists("*GetBladeIndent")');
      let indentexpr;
      if (existsBladeIndent === 1) {
        indentexpr = "GetBladeIndent()";
      } else {
        indentexpr = await (await import_coc16.workspace.nvim.buffer).getOption("indentexpr");
      }
      try {
        await import_coc16.workspace.nvim.command("setlocal iskeyword+=:");
        await import_coc16.workspace.nvim.command("setlocal iskeyword+=-");
        await import_coc16.workspace.nvim.command("setlocal iskeyword+=.");
        await import_coc16.workspace.nvim.command(`setlocal indentexpr=${indentexpr}`);
        import_coc16.workspace.registerAutocmd({
          event: "FileType",
          pattern: "blade",
          request: true,
          callback: async () => {
            await import_coc16.workspace.nvim.command("setlocal iskeyword+=:");
            await import_coc16.workspace.nvim.command("setlocal iskeyword+=-");
            await import_coc16.workspace.nvim.command("setlocal iskeyword+=.");
          }
        });
        import_coc16.workspace.registerAutocmd({
          event: "InsertEnter",
          pattern: "*.blade.php",
          request: true,
          callback: async () => {
            await import_coc16.workspace.nvim.command("setlocal indentexpr=");
          }
        });
        import_coc16.workspace.registerAutocmd({
          event: "InsertLeave",
          pattern: "*.blade.php",
          request: true,
          callback: async () => {
            await import_coc16.workspace.nvim.command(`setlocal indentexpr=${indentexpr}`);
          }
        });
      } catch {
      }
    }
    if (getConfigBladeCompletionEnableSnippets()) {
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("blade-snippets", "blade", ["blade"], new BladeSnippetsCompletionProvider(context, outputChannel), [":"]));
    }
    if (getConfigBladeCompletionEnableDirective()) {
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("blade-directive", "blade", ["blade"], new BladeDirectiveCompletionProvider(context), ["@"]));
    }
    if (getConfigBladeCompletionEnableLivewireDirectiveComponent()) {
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("livewire-directive-component", "livewire", ["blade"], new LivewireDirectiveComponentProvider(), ["("]));
    }
    if (getConfigBladeCompletionEnableLivewireTag()) {
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("livewire-tag", "livewire", ["blade"], new LivewireTagProvider(), [
        "<"
      ]));
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("livewire-tag-component", "livewire", ["blade"], new LivewireTagComponentProvider()));
    }
    if (getConfigBladeCompletionEnableLivewireWire()) {
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("livewire-wire", "livewire", ["blade"], new LivewireWireProvider(), [
        "w"
      ]));
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("livewire-wire-event", "livewire", ["blade"], new LivewireWireEventProvider(), [":", "."]));
      context.subscriptions.push(import_coc16.languages.registerCompletionItemProvider("livewire-wire-action", "livewire", ["blade"], new LivewireWireActionProvider(), ["=", "'", '"']));
    }
  }
  context.subscriptions.push(import_coc16.languages.registerHoverProvider(languageSelector, new BladeHoverProvider(context)));
  context.subscriptions.push(import_coc16.languages.registerDefinitionProvider(languageSelector, new BladeDefinitionProvider()));
  const codeActionProvider = new BladeCodeActionProvider();
  context.subscriptions.push(import_coc16.languages.registerCodeActionProvider(languageSelector, codeActionProvider, "blade"));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
